### 问题记录：

2018年10月27日14:32:50

当前版本(894ba8c6e7b2d41f3ae7180a511678872904dfd6)有一个很容易重现的问题，当TcpServer有单独的IO线程时，当主EventLoop线程接收到新的连接，会将新连接分发给IO线程，而IO线程此时很有可能正阻塞在poll()系统调用中，当然它也不会知道有新的socket需要加入pollfds进行监听。此时，如果新连接的socket有任何事件发生，系统都不会知道，只有等当前poll()返回，EventLoop再次调用poll()的时候，才会检测到新连接上发生的事件。如果poll()的超时时间设置为永远等待，那将永远也不能处理新连接的任何事件。解决办法是，在EventLoop添加一个特殊的描述符(eventfd)，并添加到poll()中进行监听它的可读事件，当需要唤起poll()的阻塞时，只需向它写入数据即可。
